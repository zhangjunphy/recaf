use std::str::FromStr;
use crate::parser::ast::*;
use crate::source_pos::{Pos, SrcSpan};
use crate::parser::lexer;
use crate::error;

grammar;

//pub Expr: Box<Expr> = {
//    <start:@L> <l:Expr> <o:ExprOp> <r:Factor> <end:@R> => Box::new(expr![Op, start, end, l, o, r]),
//    Factor,
//};
//
//ExprOp: Opcode = {
//    "+" => Opcode::Add,
//    "-" => Opcode::Sub,
//};
//
//Factor: Box<Expr> = {
//    <start:@L> <l:Factor> <o:FactorOp> <r:Term> <end:@R> => Box::new(expr![Op, start, end, l, o, r]),
//    Term,
//};
//
//FactorOp: Opcode = {
//    "*" => Opcode::Mul,
//    "/" => Opcode::Div,
//};
//
//Term: Box<Expr> = {
//    <start:@L> <n:Num> <end:@R> => Box::new(expr![Number, start, end, n]),
//    "(" <Expr> ")",
//};
//
//Num: i64 = <r"[0-9]+"> => i64::from_str(<>).unwrap();

pub ID: ID = <start:@L> <id:"id"> <end:@R> => ID{id: id, range: Some(SrcSpan::new(start, end))};

pub IntLiteral: Literal = {
    "dec" => Literal::Int(i64::from_str(<>.as_str()).unwrap()),
    "hex" => Literal::Int(i64::from_str(<>.as_str()).unwrap()),
};

pub BoolLiteral: Literal = {
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

pub CharLiteral: Literal = {
    "char" => Literal::Char(<>)
};

extern {
    type Location = Pos;
    type Error = error::Error;

    enum lexer::Tok {
        "import" => lexer::Tok::Import,
        "if" => lexer::Tok::If,
        "for" => lexer::Tok::For,
        "while" => lexer::Tok::While,
        "return" => lexer::Tok::Return,
        "break" => lexer::Tok::Break,
        "continue" => lexer::Tok::Continue,
        "int" => lexer::Tok::Int,
        "bool" => lexer::Tok::Bool,
        "void" => lexer::Tok::Void,
        "id" => lexer::Tok::ID(<String>),
        "true" => lexer::Tok::True,
        "false" => lexer::Tok::False,
        "hex" => lexer::Tok::HexLiteral(<String>),
        "dec" => lexer::Tok::DecLiteral(<String>),
        "char" => lexer::Tok::Char(<char>),
        "string" => lexer::Tok::String(<String>),
        "assign" => lexer::Tok::AssignOp(<String>),
        "incr" => lexer::Tok::IncrementOp(<String>),
        "arith" => lexer::Tok::ArithOp(<String>),
        "rel" => lexer::Tok::RelOp(<String>),
        "eq" => lexer::Tok::EqOp(<String>),
        "cond" => lexer::Tok::CondOp(<String>),
        "?" => lexer::Tok::QMark,
        ":" => lexer::Tok::Colon,
        "(" => lexer::Tok::LParen,
        ")" => lexer::Tok::RParen,
        "[" => lexer::Tok::LBrack,
        "]" => lexer::Tok::RBrack,
        "{" => lexer::Tok::LCurly,
        "}" => lexer::Tok::RCurly,
        ";" => lexer::Tok::Semicolon,
    }
}